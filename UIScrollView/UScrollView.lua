---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by ChenXingHua.
--- DateTime: 2019/1/5 16:38
---
local UScrollView = class("UScrollView")

function UScrollView:ctor(ScrollObject,ItemObject,item,Orientation)
    self.gameObject = ScrollObject                      --滚动条
    self.transform = ScrollObject.transform
    self.ItemObject = ItemObject                        --当个子类

    if item == nil then
        item = require("Core.UIComponents.UIScrollView.UIRenderItem")
    end
    self.RenderItem = item                              --渲染子类

    self._scrollOrientation = Orientation               --方向

    if self._scrollOrientation == nil then
        self._scrollOrientation = ScrollOrientation.VERTICAL
    end

    self.ItemSizeDelta = self.ItemObject:GetComponent("RectTransform").sizeDelta  --子类item大小

    self._itemsVisible = 0                              --视口可以显示多少Item

    self._scrollRect = self.gameObject:GetComponent("ScrollRect")
    self._viewport = self.gameObject:Find("Viewport"):GetComponent("RectTransform")
    self._content = self.gameObject:Find("Viewport/Content"):GetComponent("RectTransform")



end

--设置刷新
function UScrollView:SetOnItemLoadedHandler(fun)
    self.OnItemLoaded = fun
end


--跳转到某个item
function UScrollView:JumpToItem(index)
    if index > self._itemsTotal or index < 0 then
        print("越界 ：" .. index )
        return
    end
    --计算context的移动
    local offsex = self._itemSize + self._Spacing
    print(index)
    for i = 1, index do
        self:SetContentPosition(offsex * (i -1))
        self:Recycle()
    end
end

--[[
    获取偏移
]]
function UScrollView:GetOffset()
    return self:GetContentPosition()
end

--[[
    跳转根据content位移
]]
function UScrollView:JumpByOffset(num)
    local temp = num / (self._itemSize + self._Spacing)
    local index = math.floor(temp)
    self:JumpToItem(index)
end

--[[
    显示隐藏
]]
function UScrollView:SetActive(active)
    if self.gameObject == nil then
        return
    end
    self.gameObject:SetActive(active)
end

--[[
    主动刷新刷新一次
]]
function UScrollView:Ref()
    for i = 1, #self._itemsList do
        local item = self._itemsList[i]
        self:ItemLoaded(item)
    end
end

--[[
    获取itemlist
]]
function UScrollView:GetItemList()
    return self._itemsList
end


function UScrollView:ItemLoaded(item,clear)
    if item ~= nil then
        if self.OnItemLoaded ~= nil then
            self.OnItemLoaded(item)
        end
        if clear ~= nil then
            self:SetOnItemLoadedHandler(nil)
        end
    end
end


function UScrollView:RefData(count)
    self._scrollRect.verticalNormalizedPosition = 1
    if self._itemsList ~= nil then
        for i = 1, #self._itemsList do
            self._itemsList[i]:Destroy()
        end
    end
    self._itemsList = nil
    self:Create(count,self._Spacing)
end

function UScrollView:Create(count,spacing)
    self._itemsVisible = 0                              --视口可以显示多少Item
    self._lastPosition = -1
    self._itemsToRecycleBefore = 0   --向上移动多少个才超过显示

    self._Spacing = spacing                                 --间隔
    self._Count = count                                     --总共多少item
    self._itemsTotal = count
    if self._scrollOrientation == ScrollOrientation.HORIZONTAL then
        self._scrollRect.vertical = false
        self._scrollRect.horizontal = true

        self._content.anchorMin = Vector2.New(0, 0)
        self._content.anchorMax = Vector2.New(0, 1)

        self._itemSize = self.ItemSizeDelta.x                --记录横向竖向长度
        self._content.sizeDelta = Vector2.New(self._itemSize * self._Count  + self._Spacing * (self._Count - 1), 0)

    elseif self._scrollOrientation == ScrollOrientation.VERTICAL then
        self._scrollRect.vertical = true
        self._scrollRect.horizontal = false

        self._content.anchorMin = Vector2.New(0, 1)
        self._content.anchorMax = Vector2.New(1, 1)

        self._itemSize = self.ItemSizeDelta.y

        self._content.sizeDelta = Vector2.New(0, self._itemSize * self._Count + self._Spacing * (self._Count - 1))

    end

    self._itemsVisible =  math.ceil(self:GetViewportSize() / self._itemSize)

    --需要创建多少个item
    local itemsToInstantiate = self._itemsVisible
    if self._itemsVisible == 1 then
        itemsToInstantiate = 5
    elseif itemsToInstantiate < self._Count then
        itemsToInstantiate = itemsToInstantiate  +  (self._itemsVisible / 2)
    end

    if itemsToInstantiate > self._Count then
        itemsToInstantiate = self._Count
    end

    self._itemsList = {}            --所有生成的Item

    --创建Item
    for i = 0, itemsToInstantiate -1 do
        local itemRender =  self:CreateNewItem(i,self._itemSize)
        itemRender:SetIndex(i+1)
        table.insert(self._itemsList,itemRender)

        self:ItemLoaded(itemRender)
    end

    self.ItemObject.gameObject:SetActive(false)

    self._lastItemIndex = #self._itemsList      --显示到那个Index 开始是整个list 随着滑动值不断变化（最后一个数字）

    self._itemsToRecycleAfter = #self._itemsList - self._itemsVisible

    self._scrollRect.onValueChanged:AddListener(function (pos)
        self:Recycle()
    end)

end

--[[
 获取视口大小
]]
function UScrollView:GetViewportSize()
    if self._scrollOrientation == ScrollOrientation.HORIZONTAL then
        return self._viewport.rect.width
    elseif self._scrollOrientation == ScrollOrientation.VERTICAL then
        return self._viewport.rect.height
    end
    return 0
end

--[[
 创建item
]]
function UScrollView:CreateNewItem(index,dimension)
    local instance = GameObject.Instantiate(self.ItemObject)
    instance.transform:SetParent(self._content.transform.transform)
    local rectTransform = instance.transform:GetComponent(typeof(UnityEngine.RectTransform))
    if  rectTransform then
        rectTransform.localScale = UnityEngine.Vector3.New(1,1,1)
        rectTransform.localPosition = Vector3.New(0,0,0)
    end

    instance.gameObject:SetActive(true)
    local position = index * (dimension + self._Spacing) + dimension / 2

    local rectTransform = instance:GetComponent("RectTransform")

    if self._scrollOrientation == ScrollOrientation.HORIZONTAL then
        rectTransform.anchorMin = Vector2.New(0, 0);
        rectTransform.anchorMax = Vector2.New(0, 1);
        rectTransform.anchoredPosition = Vector2.New(position, 0);
        rectTransform.offsetMin = Vector2.New(rectTransform.offsetMin.x, 0);
        rectTransform.offsetMax = Vector2.New(rectTransform.offsetMax.x, 0);
    elseif self._scrollOrientation == ScrollOrientation.VERTICAL then
        rectTransform.anchorMin = Vector2.New(0, 1);
        rectTransform.anchorMax = Vector2.New(1, 1);
        rectTransform.anchoredPosition = Vector2.New(0, -position);
        rectTransform.offsetMin = Vector2.New(0, rectTransform.offsetMin.y);
        rectTransform.offsetMax = Vector2.New(0, rectTransform.offsetMax.y);
    end
    return self.RenderItem.new(instance)
end

--滚动(只有一个滚动时候才触发)
function UScrollView:Recycle()

    if self._lastPosition == -1 then
        self._lastPosition = self:GetContentPosition()
        return
    end
    local displacedRows = math.floor(math.abs((self:GetContentPosition() - self._lastPosition) / self._itemSize))
    if displacedRows == 0  then
        return
    end

    local direction = self:GetScrollDirection()
    for i = 1, displacedRows do
        if direction == ScrollDirection.NEXT then
            self:NextItem()
        end
        if direction == ScrollDirection.PREVIOUS  then
            self:PreviousItem()
        end

        if((direction == ScrollDirection.NEXT and  self._scrollOrientation ==ScrollOrientation.VERTICAL) or(direction == ScrollDirection.PREVIOUS and self._scrollOrientation == ScrollOrientation.HORIZONTAL )) then
            self._lastPosition = self._lastPosition + self._itemSize + self._Spacing
        else
            self._lastPosition = self._lastPosition - self._itemSize - self._Spacing
        end

    end

end

function UScrollView:GetContentPosition()
    if self._scrollOrientation == ScrollOrientation.HORIZONTAL then
        return self._content.anchoredPosition.x
    end
    if self._scrollOrientation ==  ScrollOrientation.VERTICAL then
        return self._content.anchoredPosition.y
    end
    return 0
end

function UScrollView:GetContentSize()
    if self._scrollOrientation == ScrollOrientation.HORIZONTAL then
        return self._content.sizeDelta.x
    end
    if self._scrollOrientation ==  ScrollOrientation.VERTICAL then
        return self._content.sizeDelta.y
    end
    return 0
end

function UScrollView:SetContentPosition(num)
    if self._scrollOrientation == ScrollOrientation.HORIZONTAL then
        self._content.anchoredPosition  = Vector3.New(-num,self._content.anchoredPosition.y,self._content.anchoredPosition.z)
    end
    if self._scrollOrientation ==  ScrollOrientation.VERTICAL then
        self._content.anchoredPosition  = Vector3.New(self._content.anchoredPosition.x,num,self._content.anchoredPosition.z)
    end
end

function UScrollView:GetScrollDirection()
    if self._scrollOrientation == ScrollOrientation.HORIZONTAL then
        if  self._lastPosition < self:GetContentPosition() then
            return ScrollDirection.PREVIOUS
        else
            return  ScrollDirection.NEXT
        end
    end
    if self._scrollOrientation == ScrollOrientation.VERTICAL then
        if  self._lastPosition > self:GetContentPosition() then
            return ScrollDirection.PREVIOUS
        else
            return  ScrollDirection.NEXT
        end
    end
    return ScrollDirection.NEXT
end

function UScrollView:NextItem()
    if (self._itemsToRecycleBefore >=  (#self._itemsList - self._itemsVisible) / 2) and  self._lastItemIndex < self._itemsTotal  then
        self._lastItemIndex = self._lastItemIndex + 1
        self:RecycleItem(ScrollDirection.NEXT)
    else
        self._itemsToRecycleBefore = self._itemsToRecycleBefore + 1
        self._itemsToRecycleAfter = self._itemsToRecycleAfter - 1
    end
end

function UScrollView:PreviousItem()
    if self._itemsToRecycleAfter >= (#self._itemsList - self._itemsVisible) / 2 and self._lastItemIndex > #self._itemsList then
        self:RecycleItem(ScrollDirection.PREVIOUS)
        self._lastItemIndex = self._lastItemIndex - 1
    else
        self._itemsToRecycleBefore = self._itemsToRecycleBefore - 1
        self._itemsToRecycleAfter = self._itemsToRecycleAfter + 1
    end
end

function UScrollView:RecycleItem(direction)
    local firstItem = self._itemsList[1]
    local lastItem = self._itemsList[#self._itemsList]

    local targetPosition = self._itemSize + self._Spacing

    if direction  == ScrollDirection.NEXT then
        if self._scrollOrientation ==ScrollOrientation.HORIZONTAL  then
            firstItem:SetPosition(Vector2.New(lastItem:GetPosition().x + targetPosition,firstItem:GetPosition().y))
        end
        if self._scrollOrientation ==  ScrollOrientation.VERTICAL then
            firstItem:SetPosition(Vector2.New(firstItem:GetPosition().x,lastItem:GetPosition().y- targetPosition))
        end

        firstItem:SetIndex(self._lastItemIndex)
        firstItem.transform:SetAsLastSibling()

        table.remove(self._itemsList,1)
        table.insert(self._itemsList,firstItem)
        self:ItemLoaded(firstItem)
    end

    if direction == ScrollDirection.PREVIOUS then
        if self._scrollOrientation ==ScrollOrientation.HORIZONTAL  then
            lastItem:SetPosition(Vector2.New(firstItem:GetPosition().x - targetPosition,lastItem:GetPosition().y))
        end
        if self._scrollOrientation ==  ScrollOrientation.VERTICAL then
            lastItem:SetPosition(Vector2.New(lastItem:GetPosition().x,firstItem:GetPosition().y + targetPosition))
        end
        lastItem:SetIndex(self._lastItemIndex - #self._itemsList)
        lastItem.transform:SetAsLastSibling()

        table.remove(self._itemsList,#self._itemsList)
        table.insert(self._itemsList,1,lastItem)
        self:ItemLoaded(lastItem)
    end

    UnityEngine.Canvas.ForceUpdateCanvases()
end

--销毁
function UScrollView:Destroy()
    self._scrollRect.verticalNormalizedPosition = 1
    if self._itemsList ~= nil then
        for i = 1, #self._itemsList do
            self._itemsList[i]:Destroy()
        end
    end
    self._itemsList = nil
    self._lastPosition = -1
    GameObject.Destroy(  self._content.gameObject)
    GameObject.Destroy(  self._viewport.gameObject)
    GameObject.Destroy(  self._scrollRect.gameObject)
    GameObject.Destroy(self.gameObject)

end

return UScrollView